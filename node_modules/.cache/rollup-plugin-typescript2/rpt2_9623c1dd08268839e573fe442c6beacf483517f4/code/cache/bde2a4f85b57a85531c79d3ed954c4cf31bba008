{"code":"import { Price } from '@uniswap/sdk-core';\r\nimport JSBI from 'jsbi';\r\nimport { Q192 } from '../internalConstants';\r\nimport { encodeSqrtRatioX96 } from './encodeSqrtRatioX96';\r\nimport { TickMath } from './tickMath';\r\n/**\r\n * Returns a price object corresponding to the input tick and the base/quote token\r\n * Inputs must be tokens because the address order is used to interpret the price represented by the tick\r\n * @param baseToken the base token of the price\r\n * @param quoteToken the quote token of the price\r\n * @param tick the tick for which to return the price\r\n */\r\nexport function tickToPrice(baseToken, quoteToken, tick) {\r\n    const sqrtRatioX96 = TickMath.getSqrtRatioAtTick(tick);\r\n    const ratioX192 = JSBI.multiply(sqrtRatioX96, sqrtRatioX96);\r\n    return baseToken.sortsBefore(quoteToken)\r\n        ? new Price(baseToken, quoteToken, Q192, ratioX192)\r\n        : new Price(baseToken, quoteToken, ratioX192, Q192);\r\n}\r\n/**\r\n * Returns the first tick for which the given price is greater than or equal to the tick price\r\n * @param price for which to return the closest tick that represents a price less than or equal to the input price,\r\n * i.e. the price of the returned tick is less than or equal to the input price\r\n */\r\nexport function priceToClosestTick(price) {\r\n    const sorted = price.baseCurrency.sortsBefore(price.quoteCurrency);\r\n    const sqrtRatioX96 = sorted\r\n        ? encodeSqrtRatioX96(price.numerator, price.denominator)\r\n        : encodeSqrtRatioX96(price.denominator, price.numerator);\r\n    let tick = TickMath.getTickAtSqrtRatio(sqrtRatioX96);\r\n    const nextTickPrice = tickToPrice(price.baseCurrency, price.quoteCurrency, tick + 1);\r\n    if (sorted) {\r\n        if (!price.lessThan(nextTickPrice)) {\r\n            tick++;\r\n        }\r\n    }\r\n    else {\r\n        if (!price.greaterThan(nextTickPrice)) {\r\n            tick++;\r\n        }\r\n    }\r\n    return tick;\r\n}\r\n//# sourceMappingURL=priceTickConversions.js.map","references":["/Users/luozhiwei/project/uniswap/v3-sdk/node_modules/@uniswap/sdk-core/dist/index.d.ts","/Users/luozhiwei/project/uniswap/v3-sdk/node_modules/jsbi/jsbi.d.ts","/Users/luozhiwei/project/uniswap/v3-sdk/src/internalConstants.ts","/Users/luozhiwei/project/uniswap/v3-sdk/src/utils/encodeSqrtRatioX96.ts","/Users/luozhiwei/project/uniswap/v3-sdk/src/utils/tickMath.ts"],"map":"{\"version\":3,\"file\":\"priceTickConversions.js\",\"sourceRoot\":\"\",\"sources\":[\"../../../../../src/utils/priceTickConversions.ts\"],\"names\":[],\"mappings\":\"AAAA,OAAO,EAAE,KAAK,EAAS,MAAM,mBAAmB,CAAA;AAChD,OAAO,IAAI,MAAM,MAAM,CAAA;AACvB,OAAO,EAAE,IAAI,EAAE,MAAM,sBAAsB,CAAA;AAC3C,OAAO,EAAE,kBAAkB,EAAE,MAAM,sBAAsB,CAAA;AACzD,OAAO,EAAE,QAAQ,EAAE,MAAM,YAAY,CAAA;AAErC;;;;;;GAMG;AACH,MAAM,UAAU,WAAW,CAAC,SAAgB,EAAE,UAAiB,EAAE,IAAY;IAC3E,MAAM,YAAY,GAAG,QAAQ,CAAC,kBAAkB,CAAC,IAAI,CAAC,CAAA;IAEtD,MAAM,SAAS,GAAG,IAAI,CAAC,QAAQ,CAAC,YAAY,EAAE,YAAY,CAAC,CAAA;IAE3D,OAAO,SAAS,CAAC,WAAW,CAAC,UAAU,CAAC;QACtC,CAAC,CAAC,IAAI,KAAK,CAAC,SAAS,EAAE,UAAU,EAAE,IAAI,EAAE,SAAS,CAAC;QACnD,CAAC,CAAC,IAAI,KAAK,CAAC,SAAS,EAAE,UAAU,EAAE,SAAS,EAAE,IAAI,CAAC,CAAA;AACvD,CAAC;AAED;;;;GAIG;AACH,MAAM,UAAU,kBAAkB,CAAC,KAA0B;IAC3D,MAAM,MAAM,GAAG,KAAK,CAAC,YAAY,CAAC,WAAW,CAAC,KAAK,CAAC,aAAa,CAAC,CAAA;IAElE,MAAM,YAAY,GAAG,MAAM;QACzB,CAAC,CAAC,kBAAkB,CAAC,KAAK,CAAC,SAAS,EAAE,KAAK,CAAC,WAAW,CAAC;QACxD,CAAC,CAAC,kBAAkB,CAAC,KAAK,CAAC,WAAW,EAAE,KAAK,CAAC,SAAS,CAAC,CAAA;IAE1D,IAAI,IAAI,GAAG,QAAQ,CAAC,kBAAkB,CAAC,YAAY,CAAC,CAAA;IACpD,MAAM,aAAa,GAAG,WAAW,CAAC,KAAK,CAAC,YAAY,EAAE,KAAK,CAAC,aAAa,EAAE,IAAI,GAAG,CAAC,CAAC,CAAA;IACpF,IAAI,MAAM,EAAE;QACV,IAAI,CAAC,KAAK,CAAC,QAAQ,CAAC,aAAa,CAAC,EAAE;YAClC,IAAI,EAAE,CAAA;SACP;KACF;SAAM;QACL,IAAI,CAAC,KAAK,CAAC,WAAW,CAAC,aAAa,CAAC,EAAE;YACrC,IAAI,EAAE,CAAA;SACP;KACF;IACD,OAAO,IAAI,CAAA;AACb,CAAC\"}","dts":{"name":"/Users/luozhiwei/project/uniswap/v3-sdk/utils/priceTickConversions.d.ts","writeByteOrderMark":false,"text":"import { Price, Token } from '@uniswap/sdk-core';\r\n/**\r\n * Returns a price object corresponding to the input tick and the base/quote token\r\n * Inputs must be tokens because the address order is used to interpret the price represented by the tick\r\n * @param baseToken the base token of the price\r\n * @param quoteToken the quote token of the price\r\n * @param tick the tick for which to return the price\r\n */\r\nexport declare function tickToPrice(baseToken: Token, quoteToken: Token, tick: number): Price<Token, Token>;\r\n/**\r\n * Returns the first tick for which the given price is greater than or equal to the tick price\r\n * @param price for which to return the closest tick that represents a price less than or equal to the input price,\r\n * i.e. the price of the returned tick is less than or equal to the input price\r\n */\r\nexport declare function priceToClosestTick(price: Price<Token, Token>): number;\r\n"}}
