{"code":"import { Fraction, Percent, Price, sortedInsert, CurrencyAmount, TradeType } from '@uniswap/sdk-core';\r\nimport invariant from 'tiny-invariant';\r\nimport { ONE, ZERO } from '../internalConstants';\r\nimport { Pool } from './pool';\r\nimport { Route } from './route';\r\n/**\r\n * Trades comparator, an extension of the input output comparator that also considers other dimensions of the trade in ranking them\r\n * @template TInput The input token, either Ether or an ERC-20\r\n * @template TOutput The output token, either Ether or an ERC-20\r\n * @template TTradeType The trade type, either exact input or exact output\r\n * @param a The first trade to compare\r\n * @param b The second trade to compare\r\n * @returns A sorted ordering for two neighboring elements in a trade array\r\n */\r\nexport function tradeComparator(a, b) {\r\n    // must have same input and output token for comparison\r\n    invariant(a.inputAmount.currency.equals(b.inputAmount.currency), 'INPUT_CURRENCY');\r\n    invariant(a.outputAmount.currency.equals(b.outputAmount.currency), 'OUTPUT_CURRENCY');\r\n    if (a.outputAmount.equalTo(b.outputAmount)) {\r\n        if (a.inputAmount.equalTo(b.inputAmount)) {\r\n            // consider the number of hops since each hop costs gas\r\n            const aHops = a.swaps.reduce((total, cur) => total + cur.route.tokenPath.length, 0);\r\n            const bHops = b.swaps.reduce((total, cur) => total + cur.route.tokenPath.length, 0);\r\n            return aHops - bHops;\r\n        }\r\n        // trade A requires less input than trade B, so A should come first\r\n        if (a.inputAmount.lessThan(b.inputAmount)) {\r\n            return -1;\r\n        }\r\n        else {\r\n            return 1;\r\n        }\r\n    }\r\n    else {\r\n        // tradeA has less output than trade B, so should come second\r\n        if (a.outputAmount.lessThan(b.outputAmount)) {\r\n            return 1;\r\n        }\r\n        else {\r\n            return -1;\r\n        }\r\n    }\r\n}\r\n/**\r\n * Represents a trade executed against a set of routes where some percentage of the input is\r\n * split across each route.\r\n *\r\n * Each route has its own set of pools. Pools can not be re-used across routes.\r\n *\r\n * Does not account for slippage, i.e., changes in price environment that can occur between\r\n * the time the trade is submitted and when it is executed.\r\n * @template TInput The input token, either Ether or an ERC-20\r\n * @template TOutput The output token, either Ether or an ERC-20\r\n * @template TTradeType The trade type, either exact input or exact output\r\n */\r\nexport class Trade {\r\n    /**\r\n     * Construct a trade by passing in the pre-computed property values\r\n     * @param routes The routes through which the trade occurs\r\n     * @param tradeType The type of trade, exact input or exact output\r\n     */\r\n    constructor({ routes, tradeType }) {\r\n        const inputCurrency = routes[0].inputAmount.currency;\r\n        const outputCurrency = routes[0].outputAmount.currency;\r\n        invariant(routes.every(({ route }) => inputCurrency.wrapped.equals(route.input.wrapped)), 'INPUT_CURRENCY_MATCH');\r\n        invariant(routes.every(({ route }) => outputCurrency.wrapped.equals(route.output.wrapped)), 'OUTPUT_CURRENCY_MATCH');\r\n        const numPools = routes.map(({ route }) => route.pools.length).reduce((total, cur) => total + cur, 0);\r\n        const poolAddressSet = new Set();\r\n        for (const { route } of routes) {\r\n            for (const pool of route.pools) {\r\n                poolAddressSet.add(Pool.getAddress(pool.token0, pool.token1, pool.fee));\r\n            }\r\n        }\r\n        invariant(numPools == poolAddressSet.size, 'POOLS_DUPLICATED');\r\n        this.swaps = routes;\r\n        this.tradeType = tradeType;\r\n    }\r\n    /**\r\n     * @deprecated Deprecated in favor of 'swaps' property. If the trade consists of multiple routes\r\n     * this will return an error.\r\n     *\r\n     * When the trade consists of just a single route, this returns the route of the trade,\r\n     * i.e. which pools the trade goes through.\r\n     */\r\n    get route() {\r\n        invariant(this.swaps.length == 1, 'MULTIPLE_ROUTES');\r\n        return this.swaps[0].route;\r\n    }\r\n    /**\r\n     * The input amount for the trade assuming no slippage.\r\n     */\r\n    get inputAmount() {\r\n        if (this._inputAmount) {\r\n            return this._inputAmount;\r\n        }\r\n        const inputCurrency = this.swaps[0].inputAmount.currency;\r\n        const totalInputFromRoutes = this.swaps\r\n            .map(({ inputAmount }) => inputAmount)\r\n            .reduce((total, cur) => total.add(cur), CurrencyAmount.fromRawAmount(inputCurrency, 0));\r\n        this._inputAmount = totalInputFromRoutes;\r\n        return this._inputAmount;\r\n    }\r\n    /**\r\n     * The output amount for the trade assuming no slippage.\r\n     */\r\n    get outputAmount() {\r\n        if (this._outputAmount) {\r\n            return this._outputAmount;\r\n        }\r\n        const outputCurrency = this.swaps[0].outputAmount.currency;\r\n        const totalOutputFromRoutes = this.swaps\r\n            .map(({ outputAmount }) => outputAmount)\r\n            .reduce((total, cur) => total.add(cur), CurrencyAmount.fromRawAmount(outputCurrency, 0));\r\n        this._outputAmount = totalOutputFromRoutes;\r\n        return this._outputAmount;\r\n    }\r\n    /**\r\n     * The price expressed in terms of output amount/input amount.\r\n     */\r\n    get executionPrice() {\r\n        return (this._executionPrice ??\r\n            (this._executionPrice = new Price(this.inputAmount.currency, this.outputAmount.currency, this.inputAmount.quotient, this.outputAmount.quotient)));\r\n    }\r\n    /**\r\n     * Returns the percent difference between the route's mid price and the price impact\r\n     */\r\n    get priceImpact() {\r\n        if (this._priceImpact) {\r\n            return this._priceImpact;\r\n        }\r\n        let spotOutputAmount = CurrencyAmount.fromRawAmount(this.outputAmount.currency, 0);\r\n        for (const { route, inputAmount } of this.swaps) {\r\n            const midPrice = route.midPrice;\r\n            spotOutputAmount = spotOutputAmount.add(midPrice.quote(inputAmount));\r\n        }\r\n        const priceImpact = spotOutputAmount.subtract(this.outputAmount).divide(spotOutputAmount);\r\n        this._priceImpact = new Percent(priceImpact.numerator, priceImpact.denominator);\r\n        return this._priceImpact;\r\n    }\r\n    /**\r\n     * Constructs an exact in trade with the given amount in and route\r\n     * @template TInput The input token, either Ether or an ERC-20\r\n     * @template TOutput The output token, either Ether or an ERC-20\r\n     * @param route The route of the exact in trade\r\n     * @param amountIn The amount being passed in\r\n     * @returns The exact in trade\r\n     */\r\n    static async exactIn(route, amountIn) {\r\n        return Trade.fromRoute(route, amountIn, TradeType.EXACT_INPUT);\r\n    }\r\n    /**\r\n     * Constructs an exact out trade with the given amount out and route\r\n     * @template TInput The input token, either Ether or an ERC-20\r\n     * @template TOutput The output token, either Ether or an ERC-20\r\n     * @param route The route of the exact out trade\r\n     * @param amountOut The amount returned by the trade\r\n     * @returns The exact out trade\r\n     */\r\n    static async exactOut(route, amountOut) {\r\n        return Trade.fromRoute(route, amountOut, TradeType.EXACT_OUTPUT);\r\n    }\r\n    /**\r\n     * Constructs a trade by simulating swaps through the given route\r\n     * @template TInput The input token, either Ether or an ERC-20.\r\n     * @template TOutput The output token, either Ether or an ERC-20.\r\n     * @template TTradeType The type of the trade, either exact in or exact out.\r\n     * @param route route to swap through\r\n     * @param amount the amount specified, either input or output, depending on tradeType\r\n     * @param tradeType whether the trade is an exact input or exact output swap\r\n     * @returns The route\r\n     */\r\n    static async fromRoute(route, amount, tradeType) {\r\n        const amounts = new Array(route.tokenPath.length);\r\n        let inputAmount;\r\n        let outputAmount;\r\n        if (tradeType === TradeType.EXACT_INPUT) {\r\n            invariant(amount.currency.equals(route.input), 'INPUT');\r\n            amounts[0] = amount.wrapped;\r\n            for (let i = 0; i < route.tokenPath.length - 1; i++) {\r\n                const pool = route.pools[i];\r\n                const [outputAmount] = await pool.getOutputAmount(amounts[i]);\r\n                amounts[i + 1] = outputAmount;\r\n            }\r\n            inputAmount = CurrencyAmount.fromFractionalAmount(route.input, amount.numerator, amount.denominator);\r\n            outputAmount = CurrencyAmount.fromFractionalAmount(route.output, amounts[amounts.length - 1].numerator, amounts[amounts.length - 1].denominator);\r\n        }\r\n        else {\r\n            invariant(amount.currency.equals(route.output), 'OUTPUT');\r\n            amounts[amounts.length - 1] = amount.wrapped;\r\n            for (let i = route.tokenPath.length - 1; i > 0; i--) {\r\n                const pool = route.pools[i - 1];\r\n                const [inputAmount] = await pool.getInputAmount(amounts[i]);\r\n                amounts[i - 1] = inputAmount;\r\n            }\r\n            inputAmount = CurrencyAmount.fromFractionalAmount(route.input, amounts[0].numerator, amounts[0].denominator);\r\n            outputAmount = CurrencyAmount.fromFractionalAmount(route.output, amount.numerator, amount.denominator);\r\n        }\r\n        return new Trade({\r\n            routes: [{ inputAmount, outputAmount, route }],\r\n            tradeType\r\n        });\r\n    }\r\n    /**\r\n     * Constructs a trade from routes by simulating swaps\r\n     *\r\n     * @template TInput The input token, either Ether or an ERC-20.\r\n     * @template TOutput The output token, either Ether or an ERC-20.\r\n     * @template TTradeType The type of the trade, either exact in or exact out.\r\n     * @param routes the routes to swap through and how much of the amount should be routed through each\r\n     * @param tradeType whether the trade is an exact input or exact output swap\r\n     * @returns The trade\r\n     */\r\n    static async fromRoutes(routes, tradeType) {\r\n        const populatedRoutes = [];\r\n        for (const { route, amount } of routes) {\r\n            const amounts = new Array(route.tokenPath.length);\r\n            let inputAmount;\r\n            let outputAmount;\r\n            if (tradeType === TradeType.EXACT_INPUT) {\r\n                invariant(amount.currency.equals(route.input), 'INPUT');\r\n                inputAmount = CurrencyAmount.fromFractionalAmount(route.input, amount.numerator, amount.denominator);\r\n                amounts[0] = CurrencyAmount.fromFractionalAmount(route.input.wrapped, amount.numerator, amount.denominator);\r\n                for (let i = 0; i < route.tokenPath.length - 1; i++) {\r\n                    const pool = route.pools[i];\r\n                    const [outputAmount] = await pool.getOutputAmount(amounts[i]);\r\n                    amounts[i + 1] = outputAmount;\r\n                }\r\n                outputAmount = CurrencyAmount.fromFractionalAmount(route.output, amounts[amounts.length - 1].numerator, amounts[amounts.length - 1].denominator);\r\n            }\r\n            else {\r\n                invariant(amount.currency.equals(route.output), 'OUTPUT');\r\n                outputAmount = CurrencyAmount.fromFractionalAmount(route.output, amount.numerator, amount.denominator);\r\n                amounts[amounts.length - 1] = CurrencyAmount.fromFractionalAmount(route.output.wrapped, amount.numerator, amount.denominator);\r\n                for (let i = route.tokenPath.length - 1; i > 0; i--) {\r\n                    const pool = route.pools[i - 1];\r\n                    const [inputAmount] = await pool.getInputAmount(amounts[i]);\r\n                    amounts[i - 1] = inputAmount;\r\n                }\r\n                inputAmount = CurrencyAmount.fromFractionalAmount(route.input, amounts[0].numerator, amounts[0].denominator);\r\n            }\r\n            populatedRoutes.push({ route, inputAmount, outputAmount });\r\n        }\r\n        return new Trade({\r\n            routes: populatedRoutes,\r\n            tradeType\r\n        });\r\n    }\r\n    /**\r\n     * Creates a trade without computing the result of swapping through the route. Useful when you have simulated the trade\r\n     * elsewhere and do not have any tick data\r\n     * @template TInput The input token, either Ether or an ERC-20\r\n     * @template TOutput The output token, either Ether or an ERC-20\r\n     * @template TTradeType The type of the trade, either exact in or exact out\r\n     * @param constructorArguments The arguments passed to the trade constructor\r\n     * @returns The unchecked trade\r\n     */\r\n    static createUncheckedTrade(constructorArguments) {\r\n        return new Trade({\r\n            ...constructorArguments,\r\n            routes: [\r\n                {\r\n                    inputAmount: constructorArguments.inputAmount,\r\n                    outputAmount: constructorArguments.outputAmount,\r\n                    route: constructorArguments.route\r\n                }\r\n            ]\r\n        });\r\n    }\r\n    /**\r\n     * Creates a trade without computing the result of swapping through the routes. Useful when you have simulated the trade\r\n     * elsewhere and do not have any tick data\r\n     * @template TInput The input token, either Ether or an ERC-20\r\n     * @template TOutput The output token, either Ether or an ERC-20\r\n     * @template TTradeType The type of the trade, either exact in or exact out\r\n     * @param constructorArguments The arguments passed to the trade constructor\r\n     * @returns The unchecked trade\r\n     */\r\n    static createUncheckedTradeWithMultipleRoutes(constructorArguments) {\r\n        return new Trade(constructorArguments);\r\n    }\r\n    /**\r\n     * Get the minimum amount that must be received from this trade for the given slippage tolerance\r\n     * @param slippageTolerance The tolerance of unfavorable slippage from the execution price of this trade\r\n     * @returns The amount out\r\n     */\r\n    minimumAmountOut(slippageTolerance, amountOut = this.outputAmount) {\r\n        invariant(!slippageTolerance.lessThan(ZERO), 'SLIPPAGE_TOLERANCE');\r\n        if (this.tradeType === TradeType.EXACT_OUTPUT) {\r\n            return amountOut;\r\n        }\r\n        else {\r\n            const slippageAdjustedAmountOut = new Fraction(ONE)\r\n                .add(slippageTolerance)\r\n                .invert()\r\n                .multiply(amountOut.quotient).quotient;\r\n            return CurrencyAmount.fromRawAmount(amountOut.currency, slippageAdjustedAmountOut);\r\n        }\r\n    }\r\n    /**\r\n     * Get the maximum amount in that can be spent via this trade for the given slippage tolerance\r\n     * @param slippageTolerance The tolerance of unfavorable slippage from the execution price of this trade\r\n     * @returns The amount in\r\n     */\r\n    maximumAmountIn(slippageTolerance, amountIn = this.inputAmount) {\r\n        invariant(!slippageTolerance.lessThan(ZERO), 'SLIPPAGE_TOLERANCE');\r\n        if (this.tradeType === TradeType.EXACT_INPUT) {\r\n            return amountIn;\r\n        }\r\n        else {\r\n            const slippageAdjustedAmountIn = new Fraction(ONE).add(slippageTolerance).multiply(amountIn.quotient).quotient;\r\n            return CurrencyAmount.fromRawAmount(amountIn.currency, slippageAdjustedAmountIn);\r\n        }\r\n    }\r\n    /**\r\n     * Return the execution price after accounting for slippage tolerance\r\n     * @param slippageTolerance the allowed tolerated slippage\r\n     * @returns The execution price\r\n     */\r\n    worstExecutionPrice(slippageTolerance) {\r\n        return new Price(this.inputAmount.currency, this.outputAmount.currency, this.maximumAmountIn(slippageTolerance).quotient, this.minimumAmountOut(slippageTolerance).quotient);\r\n    }\r\n    /**\r\n     * Given a list of pools, and a fixed amount in, returns the top `maxNumResults` trades that go from an input token\r\n     * amount to an output token, making at most `maxHops` hops.\r\n     * Note this does not consider aggregation, as routes are linear. It's possible a better route exists by splitting\r\n     * the amount in among multiple routes.\r\n     * @param pools the pools to consider in finding the best trade\r\n     * @param nextAmountIn exact amount of input currency to spend\r\n     * @param currencyOut the desired currency out\r\n     * @param maxNumResults maximum number of results to return\r\n     * @param maxHops maximum number of hops a returned trade can make, e.g. 1 hop goes through a single pool\r\n     * @param currentPools used in recursion; the current list of pools\r\n     * @param currencyAmountIn used in recursion; the original value of the currencyAmountIn parameter\r\n     * @param bestTrades used in recursion; the current list of best trades\r\n     * @returns The exact in trade\r\n     */\r\n    static async bestTradeExactIn(pools, currencyAmountIn, currencyOut, { maxNumResults = 3, maxHops = 3 } = {}, \r\n    // used in recursion.\r\n    currentPools = [], nextAmountIn = currencyAmountIn, bestTrades = []) {\r\n        invariant(pools.length > 0, 'POOLS');\r\n        invariant(maxHops > 0, 'MAX_HOPS');\r\n        invariant(currencyAmountIn === nextAmountIn || currentPools.length > 0, 'INVALID_RECURSION');\r\n        const amountIn = nextAmountIn.wrapped;\r\n        const tokenOut = currencyOut.wrapped;\r\n        for (let i = 0; i < pools.length; i++) {\r\n            const pool = pools[i];\r\n            // pool irrelevant\r\n            if (!pool.token0.equals(amountIn.currency) && !pool.token1.equals(amountIn.currency))\r\n                continue;\r\n            let amountOut;\r\n            try {\r\n                ;\r\n                [amountOut] = await pool.getOutputAmount(amountIn);\r\n            }\r\n            catch (error) {\r\n                // input too low\r\n                if (error.isInsufficientInputAmountError) {\r\n                    continue;\r\n                }\r\n                throw error;\r\n            }\r\n            // we have arrived at the output token, so this is the final trade of one of the paths\r\n            if (amountOut.currency.isToken && amountOut.currency.equals(tokenOut)) {\r\n                sortedInsert(bestTrades, await Trade.fromRoute(new Route([...currentPools, pool], currencyAmountIn.currency, currencyOut), currencyAmountIn, TradeType.EXACT_INPUT), maxNumResults, tradeComparator);\r\n            }\r\n            else if (maxHops > 1 && pools.length > 1) {\r\n                const poolsExcludingThisPool = pools.slice(0, i).concat(pools.slice(i + 1, pools.length));\r\n                // otherwise, consider all the other paths that lead from this token as long as we have not exceeded maxHops\r\n                await Trade.bestTradeExactIn(poolsExcludingThisPool, currencyAmountIn, currencyOut, {\r\n                    maxNumResults,\r\n                    maxHops: maxHops - 1\r\n                }, [...currentPools, pool], amountOut, bestTrades);\r\n            }\r\n        }\r\n        return bestTrades;\r\n    }\r\n    /**\r\n     * similar to the above method but instead targets a fixed output amount\r\n     * given a list of pools, and a fixed amount out, returns the top `maxNumResults` trades that go from an input token\r\n     * to an output token amount, making at most `maxHops` hops\r\n     * note this does not consider aggregation, as routes are linear. it's possible a better route exists by splitting\r\n     * the amount in among multiple routes.\r\n     * @param pools the pools to consider in finding the best trade\r\n     * @param currencyIn the currency to spend\r\n     * @param currencyAmountOut the desired currency amount out\r\n     * @param nextAmountOut the exact amount of currency out\r\n     * @param maxNumResults maximum number of results to return\r\n     * @param maxHops maximum number of hops a returned trade can make, e.g. 1 hop goes through a single pool\r\n     * @param currentPools used in recursion; the current list of pools\r\n     * @param bestTrades used in recursion; the current list of best trades\r\n     * @returns The exact out trade\r\n     */\r\n    static async bestTradeExactOut(pools, currencyIn, currencyAmountOut, { maxNumResults = 3, maxHops = 3 } = {}, \r\n    // used in recursion.\r\n    currentPools = [], nextAmountOut = currencyAmountOut, bestTrades = []) {\r\n        invariant(pools.length > 0, 'POOLS');\r\n        invariant(maxHops > 0, 'MAX_HOPS');\r\n        invariant(currencyAmountOut === nextAmountOut || currentPools.length > 0, 'INVALID_RECURSION');\r\n        const amountOut = nextAmountOut.wrapped;\r\n        const tokenIn = currencyIn.wrapped;\r\n        for (let i = 0; i < pools.length; i++) {\r\n            const pool = pools[i];\r\n            // pool irrelevant\r\n            if (!pool.token0.equals(amountOut.currency) && !pool.token1.equals(amountOut.currency))\r\n                continue;\r\n            let amountIn;\r\n            try {\r\n                ;\r\n                [amountIn] = await pool.getInputAmount(amountOut);\r\n            }\r\n            catch (error) {\r\n                // not enough liquidity in this pool\r\n                if (error.isInsufficientReservesError) {\r\n                    continue;\r\n                }\r\n                throw error;\r\n            }\r\n            // we have arrived at the input token, so this is the first trade of one of the paths\r\n            if (amountIn.currency.equals(tokenIn)) {\r\n                sortedInsert(bestTrades, await Trade.fromRoute(new Route([pool, ...currentPools], currencyIn, currencyAmountOut.currency), currencyAmountOut, TradeType.EXACT_OUTPUT), maxNumResults, tradeComparator);\r\n            }\r\n            else if (maxHops > 1 && pools.length > 1) {\r\n                const poolsExcludingThisPool = pools.slice(0, i).concat(pools.slice(i + 1, pools.length));\r\n                // otherwise, consider all the other paths that arrive at this token as long as we have not exceeded maxHops\r\n                await Trade.bestTradeExactOut(poolsExcludingThisPool, currencyIn, currencyAmountOut, {\r\n                    maxNumResults,\r\n                    maxHops: maxHops - 1\r\n                }, [pool, ...currentPools], amountIn, bestTrades);\r\n            }\r\n        }\r\n        return bestTrades;\r\n    }\r\n}\r\n//# sourceMappingURL=trade.js.map","references":["/Users/luozhiwei/project/uniswap/v3-sdk/node_modules/@uniswap/sdk-core/dist/index.d.ts","/Users/luozhiwei/project/uniswap/v3-sdk/node_modules/tiny-invariant/dist/tiny-invariant.d.ts","/Users/luozhiwei/project/uniswap/v3-sdk/src/internalConstants.ts","/Users/luozhiwei/project/uniswap/v3-sdk/src/entities/pool.ts","/Users/luozhiwei/project/uniswap/v3-sdk/src/entities/route.ts"],"map":"{\"version\":3,\"file\":\"trade.js\",\"sourceRoot\":\"\",\"sources\":[\"../../../../../src/entities/trade.ts\"],\"names\":[],\"mappings\":\"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\"}","dts":{"name":"/Users/luozhiwei/project/uniswap/v3-sdk/entities/trade.d.ts","writeByteOrderMark":false,"text":"import { Currency, Percent, Price, CurrencyAmount, TradeType } from '@uniswap/sdk-core';\r\nimport { Pool } from './pool';\r\nimport { Route } from './route';\r\n/**\r\n * Trades comparator, an extension of the input output comparator that also considers other dimensions of the trade in ranking them\r\n * @template TInput The input token, either Ether or an ERC-20\r\n * @template TOutput The output token, either Ether or an ERC-20\r\n * @template TTradeType The trade type, either exact input or exact output\r\n * @param a The first trade to compare\r\n * @param b The second trade to compare\r\n * @returns A sorted ordering for two neighboring elements in a trade array\r\n */\r\nexport declare function tradeComparator<TInput extends Currency, TOutput extends Currency, TTradeType extends TradeType>(a: Trade<TInput, TOutput, TTradeType>, b: Trade<TInput, TOutput, TTradeType>): number;\r\nexport interface BestTradeOptions {\r\n    maxNumResults?: number;\r\n    maxHops?: number;\r\n}\r\n/**\r\n * Represents a trade executed against a set of routes where some percentage of the input is\r\n * split across each route.\r\n *\r\n * Each route has its own set of pools. Pools can not be re-used across routes.\r\n *\r\n * Does not account for slippage, i.e., changes in price environment that can occur between\r\n * the time the trade is submitted and when it is executed.\r\n * @template TInput The input token, either Ether or an ERC-20\r\n * @template TOutput The output token, either Ether or an ERC-20\r\n * @template TTradeType The trade type, either exact input or exact output\r\n */\r\nexport declare class Trade<TInput extends Currency, TOutput extends Currency, TTradeType extends TradeType> {\r\n    /**\r\n     * @deprecated Deprecated in favor of 'swaps' property. If the trade consists of multiple routes\r\n     * this will return an error.\r\n     *\r\n     * When the trade consists of just a single route, this returns the route of the trade,\r\n     * i.e. which pools the trade goes through.\r\n     */\r\n    get route(): Route<TInput, TOutput>;\r\n    /**\r\n     * The swaps of the trade, i.e. which routes and how much is swapped in each that\r\n     * make up the trade.\r\n     */\r\n    readonly swaps: {\r\n        route: Route<TInput, TOutput>;\r\n        inputAmount: CurrencyAmount<TInput>;\r\n        outputAmount: CurrencyAmount<TOutput>;\r\n    }[];\r\n    /**\r\n     * The type of the trade, either exact in or exact out.\r\n     */\r\n    readonly tradeType: TTradeType;\r\n    /**\r\n     * The cached result of the input amount computation\r\n     * @private\r\n     */\r\n    private _inputAmount;\r\n    /**\r\n     * The input amount for the trade assuming no slippage.\r\n     */\r\n    get inputAmount(): CurrencyAmount<TInput>;\r\n    /**\r\n     * The cached result of the output amount computation\r\n     * @private\r\n     */\r\n    private _outputAmount;\r\n    /**\r\n     * The output amount for the trade assuming no slippage.\r\n     */\r\n    get outputAmount(): CurrencyAmount<TOutput>;\r\n    /**\r\n     * The cached result of the computed execution price\r\n     * @private\r\n     */\r\n    private _executionPrice;\r\n    /**\r\n     * The price expressed in terms of output amount/input amount.\r\n     */\r\n    get executionPrice(): Price<TInput, TOutput>;\r\n    /**\r\n     * The cached result of the price impact computation\r\n     * @private\r\n     */\r\n    private _priceImpact;\r\n    /**\r\n     * Returns the percent difference between the route's mid price and the price impact\r\n     */\r\n    get priceImpact(): Percent;\r\n    /**\r\n     * Constructs an exact in trade with the given amount in and route\r\n     * @template TInput The input token, either Ether or an ERC-20\r\n     * @template TOutput The output token, either Ether or an ERC-20\r\n     * @param route The route of the exact in trade\r\n     * @param amountIn The amount being passed in\r\n     * @returns The exact in trade\r\n     */\r\n    static exactIn<TInput extends Currency, TOutput extends Currency>(route: Route<TInput, TOutput>, amountIn: CurrencyAmount<TInput>): Promise<Trade<TInput, TOutput, TradeType.EXACT_INPUT>>;\r\n    /**\r\n     * Constructs an exact out trade with the given amount out and route\r\n     * @template TInput The input token, either Ether or an ERC-20\r\n     * @template TOutput The output token, either Ether or an ERC-20\r\n     * @param route The route of the exact out trade\r\n     * @param amountOut The amount returned by the trade\r\n     * @returns The exact out trade\r\n     */\r\n    static exactOut<TInput extends Currency, TOutput extends Currency>(route: Route<TInput, TOutput>, amountOut: CurrencyAmount<TOutput>): Promise<Trade<TInput, TOutput, TradeType.EXACT_OUTPUT>>;\r\n    /**\r\n     * Constructs a trade by simulating swaps through the given route\r\n     * @template TInput The input token, either Ether or an ERC-20.\r\n     * @template TOutput The output token, either Ether or an ERC-20.\r\n     * @template TTradeType The type of the trade, either exact in or exact out.\r\n     * @param route route to swap through\r\n     * @param amount the amount specified, either input or output, depending on tradeType\r\n     * @param tradeType whether the trade is an exact input or exact output swap\r\n     * @returns The route\r\n     */\r\n    static fromRoute<TInput extends Currency, TOutput extends Currency, TTradeType extends TradeType>(route: Route<TInput, TOutput>, amount: TTradeType extends TradeType.EXACT_INPUT ? CurrencyAmount<TInput> : CurrencyAmount<TOutput>, tradeType: TTradeType): Promise<Trade<TInput, TOutput, TTradeType>>;\r\n    /**\r\n     * Constructs a trade from routes by simulating swaps\r\n     *\r\n     * @template TInput The input token, either Ether or an ERC-20.\r\n     * @template TOutput The output token, either Ether or an ERC-20.\r\n     * @template TTradeType The type of the trade, either exact in or exact out.\r\n     * @param routes the routes to swap through and how much of the amount should be routed through each\r\n     * @param tradeType whether the trade is an exact input or exact output swap\r\n     * @returns The trade\r\n     */\r\n    static fromRoutes<TInput extends Currency, TOutput extends Currency, TTradeType extends TradeType>(routes: {\r\n        amount: TTradeType extends TradeType.EXACT_INPUT ? CurrencyAmount<TInput> : CurrencyAmount<TOutput>;\r\n        route: Route<TInput, TOutput>;\r\n    }[], tradeType: TTradeType): Promise<Trade<TInput, TOutput, TTradeType>>;\r\n    /**\r\n     * Creates a trade without computing the result of swapping through the route. Useful when you have simulated the trade\r\n     * elsewhere and do not have any tick data\r\n     * @template TInput The input token, either Ether or an ERC-20\r\n     * @template TOutput The output token, either Ether or an ERC-20\r\n     * @template TTradeType The type of the trade, either exact in or exact out\r\n     * @param constructorArguments The arguments passed to the trade constructor\r\n     * @returns The unchecked trade\r\n     */\r\n    static createUncheckedTrade<TInput extends Currency, TOutput extends Currency, TTradeType extends TradeType>(constructorArguments: {\r\n        route: Route<TInput, TOutput>;\r\n        inputAmount: CurrencyAmount<TInput>;\r\n        outputAmount: CurrencyAmount<TOutput>;\r\n        tradeType: TTradeType;\r\n    }): Trade<TInput, TOutput, TTradeType>;\r\n    /**\r\n     * Creates a trade without computing the result of swapping through the routes. Useful when you have simulated the trade\r\n     * elsewhere and do not have any tick data\r\n     * @template TInput The input token, either Ether or an ERC-20\r\n     * @template TOutput The output token, either Ether or an ERC-20\r\n     * @template TTradeType The type of the trade, either exact in or exact out\r\n     * @param constructorArguments The arguments passed to the trade constructor\r\n     * @returns The unchecked trade\r\n     */\r\n    static createUncheckedTradeWithMultipleRoutes<TInput extends Currency, TOutput extends Currency, TTradeType extends TradeType>(constructorArguments: {\r\n        routes: {\r\n            route: Route<TInput, TOutput>;\r\n            inputAmount: CurrencyAmount<TInput>;\r\n            outputAmount: CurrencyAmount<TOutput>;\r\n        }[];\r\n        tradeType: TTradeType;\r\n    }): Trade<TInput, TOutput, TTradeType>;\r\n    /**\r\n     * Construct a trade by passing in the pre-computed property values\r\n     * @param routes The routes through which the trade occurs\r\n     * @param tradeType The type of trade, exact input or exact output\r\n     */\r\n    private constructor();\r\n    /**\r\n     * Get the minimum amount that must be received from this trade for the given slippage tolerance\r\n     * @param slippageTolerance The tolerance of unfavorable slippage from the execution price of this trade\r\n     * @returns The amount out\r\n     */\r\n    minimumAmountOut(slippageTolerance: Percent, amountOut?: CurrencyAmount<TOutput>): CurrencyAmount<TOutput>;\r\n    /**\r\n     * Get the maximum amount in that can be spent via this trade for the given slippage tolerance\r\n     * @param slippageTolerance The tolerance of unfavorable slippage from the execution price of this trade\r\n     * @returns The amount in\r\n     */\r\n    maximumAmountIn(slippageTolerance: Percent, amountIn?: CurrencyAmount<TInput>): CurrencyAmount<TInput>;\r\n    /**\r\n     * Return the execution price after accounting for slippage tolerance\r\n     * @param slippageTolerance the allowed tolerated slippage\r\n     * @returns The execution price\r\n     */\r\n    worstExecutionPrice(slippageTolerance: Percent): Price<TInput, TOutput>;\r\n    /**\r\n     * Given a list of pools, and a fixed amount in, returns the top `maxNumResults` trades that go from an input token\r\n     * amount to an output token, making at most `maxHops` hops.\r\n     * Note this does not consider aggregation, as routes are linear. It's possible a better route exists by splitting\r\n     * the amount in among multiple routes.\r\n     * @param pools the pools to consider in finding the best trade\r\n     * @param nextAmountIn exact amount of input currency to spend\r\n     * @param currencyOut the desired currency out\r\n     * @param maxNumResults maximum number of results to return\r\n     * @param maxHops maximum number of hops a returned trade can make, e.g. 1 hop goes through a single pool\r\n     * @param currentPools used in recursion; the current list of pools\r\n     * @param currencyAmountIn used in recursion; the original value of the currencyAmountIn parameter\r\n     * @param bestTrades used in recursion; the current list of best trades\r\n     * @returns The exact in trade\r\n     */\r\n    static bestTradeExactIn<TInput extends Currency, TOutput extends Currency>(pools: Pool[], currencyAmountIn: CurrencyAmount<TInput>, currencyOut: TOutput, { maxNumResults, maxHops }?: BestTradeOptions, currentPools?: Pool[], nextAmountIn?: CurrencyAmount<Currency>, bestTrades?: Trade<TInput, TOutput, TradeType.EXACT_INPUT>[]): Promise<Trade<TInput, TOutput, TradeType.EXACT_INPUT>[]>;\r\n    /**\r\n     * similar to the above method but instead targets a fixed output amount\r\n     * given a list of pools, and a fixed amount out, returns the top `maxNumResults` trades that go from an input token\r\n     * to an output token amount, making at most `maxHops` hops\r\n     * note this does not consider aggregation, as routes are linear. it's possible a better route exists by splitting\r\n     * the amount in among multiple routes.\r\n     * @param pools the pools to consider in finding the best trade\r\n     * @param currencyIn the currency to spend\r\n     * @param currencyAmountOut the desired currency amount out\r\n     * @param nextAmountOut the exact amount of currency out\r\n     * @param maxNumResults maximum number of results to return\r\n     * @param maxHops maximum number of hops a returned trade can make, e.g. 1 hop goes through a single pool\r\n     * @param currentPools used in recursion; the current list of pools\r\n     * @param bestTrades used in recursion; the current list of best trades\r\n     * @returns The exact out trade\r\n     */\r\n    static bestTradeExactOut<TInput extends Currency, TOutput extends Currency>(pools: Pool[], currencyIn: TInput, currencyAmountOut: CurrencyAmount<TOutput>, { maxNumResults, maxHops }?: BestTradeOptions, currentPools?: Pool[], nextAmountOut?: CurrencyAmount<Currency>, bestTrades?: Trade<TInput, TOutput, TradeType.EXACT_OUTPUT>[]): Promise<Trade<TInput, TOutput, TradeType.EXACT_OUTPUT>[]>;\r\n}\r\n"}}
