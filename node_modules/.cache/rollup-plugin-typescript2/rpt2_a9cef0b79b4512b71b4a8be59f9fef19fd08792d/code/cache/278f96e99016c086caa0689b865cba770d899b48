{"code":"import { currencyEquals, Fraction, Price, sortedInsert, CurrencyAmount, TradeType, wrappedCurrency, wrappedCurrencyAmount, computePriceImpact } from '@uniswap/sdk-core';\r\nimport invariant from 'tiny-invariant';\r\nimport { ONE, ZERO } from '../internalConstants';\r\nimport { Route } from './route';\r\n// extension of the input output comparator that also considers other dimensions of the trade in ranking them\r\nexport function tradeComparator(a, b) {\r\n    // must have same input and output token for comparison\r\n    invariant(currencyEquals(a.inputAmount.currency, b.inputAmount.currency), 'INPUT_CURRENCY');\r\n    invariant(currencyEquals(a.outputAmount.currency, b.outputAmount.currency), 'OUTPUT_CURRENCY');\r\n    if (a.outputAmount.equalTo(b.outputAmount)) {\r\n        if (a.inputAmount.equalTo(b.inputAmount)) {\r\n            // consider the number of hops since each hop costs gas\r\n            return a.route.tokenPath.length - b.route.tokenPath.length;\r\n        }\r\n        // trade A requires less input than trade B, so A should come first\r\n        if (a.inputAmount.lessThan(b.inputAmount)) {\r\n            return -1;\r\n        }\r\n        else {\r\n            return 1;\r\n        }\r\n    }\r\n    else {\r\n        // tradeA has less output than trade B, so should come second\r\n        if (a.outputAmount.lessThan(b.outputAmount)) {\r\n            return 1;\r\n        }\r\n        else {\r\n            return -1;\r\n        }\r\n    }\r\n}\r\n/**\r\n * Represents a trade executed against a list of pools.\r\n * Does not account for slippage, i.e. trades that front run this trade and move the price.\r\n */\r\nexport class Trade {\r\n    /**\r\n     * Construct a trade by passing in the pre-computed property values\r\n     * @param route the route through which the trade occurs\r\n     * @param inputAmount the amount of input paid in the trade\r\n     * @param outputAmount the amount of output received in the trade\r\n     * @param tradeType the type of trade, exact input or exact output\r\n     */\r\n    constructor({ route, inputAmount, outputAmount, tradeType }) {\r\n        invariant(currencyEquals(inputAmount.currency, route.input), 'INPUT_CURRENCY_MATCH');\r\n        invariant(currencyEquals(outputAmount.currency, route.output), 'OUTPUT_CURRENCY_MATCH');\r\n        this.route = route;\r\n        this.inputAmount = inputAmount;\r\n        this.outputAmount = outputAmount;\r\n        this.tradeType = tradeType;\r\n    }\r\n    /**\r\n     * The price expressed in terms of output amount/input amount.\r\n     */\r\n    get executionPrice() {\r\n        return (this._executionPrice ??\r\n            (this._executionPrice = new Price(this.inputAmount.currency, this.outputAmount.currency, this.inputAmount.quotient, this.outputAmount.quotient)));\r\n    }\r\n    /**\r\n     * Returns the percent difference between the route's mid price and the price impact\r\n     */\r\n    get priceImpact() {\r\n        return (this._priceImpact ??\r\n            (this._priceImpact = computePriceImpact(this.route.midPrice, this.inputAmount, this.outputAmount)));\r\n    }\r\n    /**\r\n     * Constructs an exact in trade with the given amount in and route\r\n     * @param route route of the exact in trade\r\n     * @param amountIn the amount being passed in\r\n     */\r\n    static async exactIn(route, amountIn) {\r\n        return Trade.fromRoute(route, amountIn, TradeType.EXACT_INPUT);\r\n    }\r\n    /**\r\n     * Constructs an exact out trade with the given amount out and route\r\n     * @param route route of the exact out trade\r\n     * @param amountOut the amount returned by the trade\r\n     */\r\n    static async exactOut(route, amountOut) {\r\n        return Trade.fromRoute(route, amountOut, TradeType.EXACT_OUTPUT);\r\n    }\r\n    /**\r\n     * Constructs a trade by simulating swaps through the given route\r\n     * @param route route to swap through\r\n     * @param amount the amount specified, either input or output, depending on tradeType\r\n     * @param tradeType whether the trade is an exact input or exact output swap\r\n     */\r\n    static async fromRoute(route, amount, tradeType) {\r\n        const amounts = new Array(route.tokenPath.length);\r\n        let inputAmount;\r\n        let outputAmount;\r\n        if (tradeType === TradeType.EXACT_INPUT) {\r\n            invariant(currencyEquals(amount.currency, route.input), 'INPUT');\r\n            amounts[0] = wrappedCurrencyAmount(amount, route.chainId);\r\n            for (let i = 0; i < route.tokenPath.length - 1; i++) {\r\n                const pool = route.pools[i];\r\n                const [outputAmount] = await pool.getOutputAmount(amounts[i]);\r\n                amounts[i + 1] = outputAmount;\r\n            }\r\n            inputAmount = CurrencyAmount.fromFractionalAmount(route.input, amount.numerator, amount.denominator);\r\n            outputAmount = CurrencyAmount.fromFractionalAmount(route.output, amounts[amounts.length - 1].numerator, amounts[amounts.length - 1].denominator);\r\n        }\r\n        else {\r\n            invariant(currencyEquals(amount.currency, route.output), 'OUTPUT');\r\n            amounts[amounts.length - 1] = wrappedCurrencyAmount(amount, route.chainId);\r\n            for (let i = route.tokenPath.length - 1; i > 0; i--) {\r\n                const pool = route.pools[i - 1];\r\n                const [inputAmount] = await pool.getInputAmount(amounts[i]);\r\n                amounts[i - 1] = inputAmount;\r\n            }\r\n            inputAmount = CurrencyAmount.fromFractionalAmount(route.input, amounts[0].numerator, amounts[0].denominator);\r\n            outputAmount = CurrencyAmount.fromFractionalAmount(route.output, amount.numerator, amount.denominator);\r\n        }\r\n        return new Trade({\r\n            route,\r\n            tradeType,\r\n            inputAmount,\r\n            outputAmount\r\n        });\r\n    }\r\n    /**\r\n     * Creates a trade without computing the result of swapping through the route. Useful when you have simulated the trade\r\n     * elsewhere and do not have any tick data\r\n     * @param constructorArguments the arguments passed to the trade constructor\r\n     */\r\n    static createUncheckedTrade(constructorArguments) {\r\n        return new Trade(constructorArguments);\r\n    }\r\n    /**\r\n     * Get the minimum amount that must be received from this trade for the given slippage tolerance\r\n     * @param slippageTolerance tolerance of unfavorable slippage from the execution price of this trade\r\n     */\r\n    minimumAmountOut(slippageTolerance) {\r\n        invariant(!slippageTolerance.lessThan(ZERO), 'SLIPPAGE_TOLERANCE');\r\n        if (this.tradeType === TradeType.EXACT_OUTPUT) {\r\n            return this.outputAmount;\r\n        }\r\n        else {\r\n            const slippageAdjustedAmountOut = new Fraction(ONE)\r\n                .add(slippageTolerance)\r\n                .invert()\r\n                .multiply(this.outputAmount.quotient).quotient;\r\n            return CurrencyAmount.fromRawAmount(this.outputAmount.currency, slippageAdjustedAmountOut);\r\n        }\r\n    }\r\n    /**\r\n     * Get the maximum amount in that can be spent via this trade for the given slippage tolerance\r\n     * @param slippageTolerance tolerance of unfavorable slippage from the execution price of this trade\r\n     */\r\n    maximumAmountIn(slippageTolerance) {\r\n        invariant(!slippageTolerance.lessThan(ZERO), 'SLIPPAGE_TOLERANCE');\r\n        if (this.tradeType === TradeType.EXACT_INPUT) {\r\n            return this.inputAmount;\r\n        }\r\n        else {\r\n            const slippageAdjustedAmountIn = new Fraction(ONE).add(slippageTolerance).multiply(this.inputAmount.quotient)\r\n                .quotient;\r\n            return CurrencyAmount.fromRawAmount(this.inputAmount.currency, slippageAdjustedAmountIn);\r\n        }\r\n    }\r\n    /**\r\n     * Return the execution price after accounting for slippage tolerance\r\n     * @param slippageTolerance the allowed tolerated slippage\r\n     */\r\n    worstExecutionPrice(slippageTolerance) {\r\n        return new Price(this.inputAmount.currency, this.outputAmount.currency, this.maximumAmountIn(slippageTolerance).quotient, this.minimumAmountOut(slippageTolerance).quotient);\r\n    }\r\n    /**\r\n     * Given a list of pools, and a fixed amount in, returns the top `maxNumResults` trades that go from an input token\r\n     * amount to an output token, making at most `maxHops` hops.\r\n     * Note this does not consider aggregation, as routes are linear. It's possible a better route exists by splitting\r\n     * the amount in among multiple routes.\r\n     * @param pools the pools to consider in finding the best trade\r\n     * @param nextAmountIn exact amount of input currency to spend\r\n     * @param currencyOut the desired currency out\r\n     * @param maxNumResults maximum number of results to return\r\n     * @param maxHops maximum number of hops a returned trade can make, e.g. 1 hop goes through a single pool\r\n     * @param currentPools used in recursion; the current list of pools\r\n     * @param currencyAmountIn used in recursion; the original value of the currencyAmountIn parameter\r\n     * @param bestTrades used in recursion; the current list of best trades\r\n     */\r\n    static async bestTradeExactIn(pools, currencyAmountIn, currencyOut, { maxNumResults = 3, maxHops = 3 } = {}, \r\n    // used in recursion.\r\n    currentPools = [], nextAmountIn = currencyAmountIn, bestTrades = []) {\r\n        invariant(pools.length > 0, 'POOLS');\r\n        invariant(maxHops > 0, 'MAX_HOPS');\r\n        invariant(currencyAmountIn === nextAmountIn || currentPools.length > 0, 'INVALID_RECURSION');\r\n        const chainId = nextAmountIn.currency.isToken\r\n            ? nextAmountIn.currency.chainId\r\n            : currencyOut.isToken\r\n                ? currencyOut.chainId\r\n                : undefined;\r\n        invariant(chainId !== undefined, 'CHAIN_ID');\r\n        const amountIn = wrappedCurrencyAmount(nextAmountIn, chainId);\r\n        const tokenOut = wrappedCurrency(currencyOut, chainId);\r\n        for (let i = 0; i < pools.length; i++) {\r\n            const pool = pools[i];\r\n            // pool irrelevant\r\n            if (!currencyEquals(pool.token0, amountIn.currency) && !currencyEquals(pool.token1, amountIn.currency))\r\n                continue;\r\n            let amountOut;\r\n            try {\r\n                ;\r\n                [amountOut] = await pool.getOutputAmount(amountIn);\r\n            }\r\n            catch (error) {\r\n                // input too low\r\n                if (error.isInsufficientInputAmountError) {\r\n                    continue;\r\n                }\r\n                throw error;\r\n            }\r\n            // we have arrived at the output token, so this is the final trade of one of the paths\r\n            if (amountOut.currency.isToken && amountOut.currency.equals(tokenOut)) {\r\n                sortedInsert(bestTrades, await Trade.fromRoute(new Route([...currentPools, pool], currencyAmountIn.currency, currencyOut), currencyAmountIn, TradeType.EXACT_INPUT), maxNumResults, tradeComparator);\r\n            }\r\n            else if (maxHops > 1 && pools.length > 1) {\r\n                const poolsExcludingThisPool = pools.slice(0, i).concat(pools.slice(i + 1, pools.length));\r\n                // otherwise, consider all the other paths that lead from this token as long as we have not exceeded maxHops\r\n                await Trade.bestTradeExactIn(poolsExcludingThisPool, currencyAmountIn, currencyOut, {\r\n                    maxNumResults,\r\n                    maxHops: maxHops - 1\r\n                }, [...currentPools, pool], amountOut, bestTrades);\r\n            }\r\n        }\r\n        return bestTrades;\r\n    }\r\n    /**\r\n     * similar to the above method but instead targets a fixed output amount\r\n     * given a list of pools, and a fixed amount out, returns the top `maxNumResults` trades that go from an input token\r\n     * to an output token amount, making at most `maxHops` hops\r\n     * note this does not consider aggregation, as routes are linear. it's possible a better route exists by splitting\r\n     * the amount in among multiple routes.\r\n     * @param pools the pools to consider in finding the best trade\r\n     * @param currencyIn the currency to spend\r\n     * @param currencyAmountOut the desired currency amount out\r\n     * @param nextAmountOut the exact amount of currency out\r\n     * @param maxNumResults maximum number of results to return\r\n     * @param maxHops maximum number of hops a returned trade can make, e.g. 1 hop goes through a single pool\r\n     * @param currentPools used in recursion; the current list of pools\r\n     * @param bestTrades used in recursion; the current list of best trades\r\n     */\r\n    static async bestTradeExactOut(pools, currencyIn, currencyAmountOut, { maxNumResults = 3, maxHops = 3 } = {}, \r\n    // used in recursion.\r\n    currentPools = [], nextAmountOut = currencyAmountOut, bestTrades = []) {\r\n        invariant(pools.length > 0, 'POOLS');\r\n        invariant(maxHops > 0, 'MAX_HOPS');\r\n        invariant(currencyAmountOut === nextAmountOut || currentPools.length > 0, 'INVALID_RECURSION');\r\n        const chainId = nextAmountOut.currency.isToken\r\n            ? nextAmountOut.currency.chainId\r\n            : currencyIn.isToken\r\n                ? currencyIn.chainId\r\n                : undefined;\r\n        invariant(chainId !== undefined, 'CHAIN_ID');\r\n        const amountOut = wrappedCurrencyAmount(nextAmountOut, chainId);\r\n        const tokenIn = wrappedCurrency(currencyIn, chainId);\r\n        for (let i = 0; i < pools.length; i++) {\r\n            const pool = pools[i];\r\n            // pool irrelevant\r\n            if (!currencyEquals(pool.token0, amountOut.currency) && !currencyEquals(pool.token1, amountOut.currency))\r\n                continue;\r\n            let amountIn;\r\n            try {\r\n                ;\r\n                [amountIn] = await pool.getInputAmount(amountOut);\r\n            }\r\n            catch (error) {\r\n                // not enough liquidity in this pool\r\n                if (error.isInsufficientReservesError) {\r\n                    continue;\r\n                }\r\n                throw error;\r\n            }\r\n            // we have arrived at the input token, so this is the first trade of one of the paths\r\n            if (currencyEquals(amountIn.currency, tokenIn)) {\r\n                sortedInsert(bestTrades, await Trade.fromRoute(new Route([pool, ...currentPools], currencyIn, currencyAmountOut.currency), currencyAmountOut, TradeType.EXACT_OUTPUT), maxNumResults, tradeComparator);\r\n            }\r\n            else if (maxHops > 1 && pools.length > 1) {\r\n                const poolsExcludingThisPool = pools.slice(0, i).concat(pools.slice(i + 1, pools.length));\r\n                // otherwise, consider all the other paths that arrive at this token as long as we have not exceeded maxHops\r\n                await Trade.bestTradeExactOut(poolsExcludingThisPool, currencyIn, currencyAmountOut, {\r\n                    maxNumResults,\r\n                    maxHops: maxHops - 1\r\n                }, [pool, ...currentPools], amountIn, bestTrades);\r\n            }\r\n        }\r\n        return bestTrades;\r\n    }\r\n}\r\n//# sourceMappingURL=trade.js.map","references":["/Users/luozhiwei/project/uniswap/v3-sdk-3.0.0-alpha.6/node_modules/@uniswap/sdk-core/dist/index.d.ts","/Users/luozhiwei/project/uniswap/v3-sdk-3.0.0-alpha.6/node_modules/tiny-invariant/dist/tiny-invariant.d.ts","/Users/luozhiwei/project/uniswap/v3-sdk-3.0.0-alpha.6/src/internalConstants.ts","/Users/luozhiwei/project/uniswap/v3-sdk-3.0.0-alpha.6/src/entities/pool.ts","/Users/luozhiwei/project/uniswap/v3-sdk-3.0.0-alpha.6/src/entities/route.ts"],"map":"{\"version\":3,\"file\":\"trade.js\",\"sourceRoot\":\"\",\"sources\":[\"../../../../../src/entities/trade.ts\"],\"names\":[],\"mappings\":\"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\"}","dts":{"name":"/Users/luozhiwei/project/uniswap/v3-sdk-3.0.0-alpha.6/entities/trade.d.ts","writeByteOrderMark":false,"text":"import { Currency, Percent, Price, CurrencyAmount, TradeType } from '@uniswap/sdk-core';\r\nimport { Pool } from './pool';\r\nimport { Route } from './route';\r\nexport declare function tradeComparator<TInput extends Currency, TOutput extends Currency, TTradeType extends TradeType>(a: Trade<TInput, TOutput, TTradeType>, b: Trade<TInput, TOutput, TTradeType>): number;\r\nexport interface BestTradeOptions {\r\n    maxNumResults?: number;\r\n    maxHops?: number;\r\n}\r\n/**\r\n * Represents a trade executed against a list of pools.\r\n * Does not account for slippage, i.e. trades that front run this trade and move the price.\r\n */\r\nexport declare class Trade<TInput extends Currency, TOutput extends Currency, TTradeType extends TradeType> {\r\n    /**\r\n     * The route of the trade, i.e. which pools the trade goes through.\r\n     */\r\n    readonly route: Route<TInput, TOutput>;\r\n    /**\r\n     * The type of the trade, either exact in or exact out.\r\n     */\r\n    readonly tradeType: TTradeType;\r\n    /**\r\n     * The input amount for the trade assuming no slippage.\r\n     */\r\n    readonly inputAmount: CurrencyAmount<TInput>;\r\n    /**\r\n     * The output amount for the trade assuming no slippage.\r\n     */\r\n    readonly outputAmount: CurrencyAmount<TOutput>;\r\n    /**\r\n     * The cached result of the computed execution price\r\n     * @private\r\n     */\r\n    private _executionPrice;\r\n    /**\r\n     * The price expressed in terms of output amount/input amount.\r\n     */\r\n    get executionPrice(): Price<TInput, TOutput>;\r\n    /**\r\n     * The cached result of the price impact computation\r\n     * @private\r\n     */\r\n    private _priceImpact;\r\n    /**\r\n     * Returns the percent difference between the route's mid price and the price impact\r\n     */\r\n    get priceImpact(): Percent;\r\n    /**\r\n     * Constructs an exact in trade with the given amount in and route\r\n     * @param route route of the exact in trade\r\n     * @param amountIn the amount being passed in\r\n     */\r\n    static exactIn<TInput extends Currency, TOutput extends Currency>(route: Route<TInput, TOutput>, amountIn: CurrencyAmount<TInput>): Promise<Trade<TInput, TOutput, TradeType.EXACT_INPUT>>;\r\n    /**\r\n     * Constructs an exact out trade with the given amount out and route\r\n     * @param route route of the exact out trade\r\n     * @param amountOut the amount returned by the trade\r\n     */\r\n    static exactOut<TInput extends Currency, TOutput extends Currency>(route: Route<TInput, TOutput>, amountOut: CurrencyAmount<TOutput>): Promise<Trade<TInput, TOutput, TradeType.EXACT_OUTPUT>>;\r\n    /**\r\n     * Constructs a trade by simulating swaps through the given route\r\n     * @param route route to swap through\r\n     * @param amount the amount specified, either input or output, depending on tradeType\r\n     * @param tradeType whether the trade is an exact input or exact output swap\r\n     */\r\n    static fromRoute<TInput extends Currency, TOutput extends Currency, TTradeType extends TradeType>(route: Route<TInput, TOutput>, amount: TTradeType extends TradeType.EXACT_INPUT ? CurrencyAmount<TInput> : CurrencyAmount<TOutput>, tradeType: TTradeType): Promise<Trade<TInput, TOutput, TTradeType>>;\r\n    /**\r\n     * Creates a trade without computing the result of swapping through the route. Useful when you have simulated the trade\r\n     * elsewhere and do not have any tick data\r\n     * @param constructorArguments the arguments passed to the trade constructor\r\n     */\r\n    static createUncheckedTrade<TInput extends Currency, TOutput extends Currency, TTradeType extends TradeType>(constructorArguments: {\r\n        route: Route<TInput, TOutput>;\r\n        inputAmount: CurrencyAmount<TInput>;\r\n        outputAmount: CurrencyAmount<TOutput>;\r\n        tradeType: TTradeType;\r\n    }): Trade<TInput, TOutput, TTradeType>;\r\n    /**\r\n     * Construct a trade by passing in the pre-computed property values\r\n     * @param route the route through which the trade occurs\r\n     * @param inputAmount the amount of input paid in the trade\r\n     * @param outputAmount the amount of output received in the trade\r\n     * @param tradeType the type of trade, exact input or exact output\r\n     */\r\n    private constructor();\r\n    /**\r\n     * Get the minimum amount that must be received from this trade for the given slippage tolerance\r\n     * @param slippageTolerance tolerance of unfavorable slippage from the execution price of this trade\r\n     */\r\n    minimumAmountOut(slippageTolerance: Percent): CurrencyAmount<TOutput>;\r\n    /**\r\n     * Get the maximum amount in that can be spent via this trade for the given slippage tolerance\r\n     * @param slippageTolerance tolerance of unfavorable slippage from the execution price of this trade\r\n     */\r\n    maximumAmountIn(slippageTolerance: Percent): CurrencyAmount<TInput>;\r\n    /**\r\n     * Return the execution price after accounting for slippage tolerance\r\n     * @param slippageTolerance the allowed tolerated slippage\r\n     */\r\n    worstExecutionPrice(slippageTolerance: Percent): Price<TInput, TOutput>;\r\n    /**\r\n     * Given a list of pools, and a fixed amount in, returns the top `maxNumResults` trades that go from an input token\r\n     * amount to an output token, making at most `maxHops` hops.\r\n     * Note this does not consider aggregation, as routes are linear. It's possible a better route exists by splitting\r\n     * the amount in among multiple routes.\r\n     * @param pools the pools to consider in finding the best trade\r\n     * @param nextAmountIn exact amount of input currency to spend\r\n     * @param currencyOut the desired currency out\r\n     * @param maxNumResults maximum number of results to return\r\n     * @param maxHops maximum number of hops a returned trade can make, e.g. 1 hop goes through a single pool\r\n     * @param currentPools used in recursion; the current list of pools\r\n     * @param currencyAmountIn used in recursion; the original value of the currencyAmountIn parameter\r\n     * @param bestTrades used in recursion; the current list of best trades\r\n     */\r\n    static bestTradeExactIn<TInput extends Currency, TOutput extends Currency>(pools: Pool[], currencyAmountIn: CurrencyAmount<TInput>, currencyOut: TOutput, { maxNumResults, maxHops }?: BestTradeOptions, currentPools?: Pool[], nextAmountIn?: CurrencyAmount<Currency>, bestTrades?: Trade<TInput, TOutput, TradeType.EXACT_INPUT>[]): Promise<Trade<TInput, TOutput, TradeType.EXACT_INPUT>[]>;\r\n    /**\r\n     * similar to the above method but instead targets a fixed output amount\r\n     * given a list of pools, and a fixed amount out, returns the top `maxNumResults` trades that go from an input token\r\n     * to an output token amount, making at most `maxHops` hops\r\n     * note this does not consider aggregation, as routes are linear. it's possible a better route exists by splitting\r\n     * the amount in among multiple routes.\r\n     * @param pools the pools to consider in finding the best trade\r\n     * @param currencyIn the currency to spend\r\n     * @param currencyAmountOut the desired currency amount out\r\n     * @param nextAmountOut the exact amount of currency out\r\n     * @param maxNumResults maximum number of results to return\r\n     * @param maxHops maximum number of hops a returned trade can make, e.g. 1 hop goes through a single pool\r\n     * @param currentPools used in recursion; the current list of pools\r\n     * @param bestTrades used in recursion; the current list of best trades\r\n     */\r\n    static bestTradeExactOut<TInput extends Currency, TOutput extends Currency>(pools: Pool[], currencyIn: Currency, currencyAmountOut: CurrencyAmount<TOutput>, { maxNumResults, maxHops }?: BestTradeOptions, currentPools?: Pool[], nextAmountOut?: CurrencyAmount<Currency>, bestTrades?: Trade<TInput, TOutput, TradeType.EXACT_OUTPUT>[]): Promise<Trade<TInput, TOutput, TradeType.EXACT_OUTPUT>[]>;\r\n}\r\n"}}
